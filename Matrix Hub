-- Services
local TS = game:GetService("TweenService")
local TSrv = game:GetService("TextService")
local Plr = game:GetService("Players")
local Core = game:GetService("CoreGui")
local RS = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ReplicatedFirst = game:GetService("ReplicatedFirst")
local UserInputService = game:GetService("UserInputService")

local player = Plr.LocalPlayer
local Camera = Workspace.CurrentCamera

if game.PlaceId ~= 155615604 then
	local TS = game:GetService("TweenService")
	local TSrv = game:GetService("TextService")
	local Core = game:GetService("CoreGui")

	local gui = Instance.new("ScreenGui", Core)
	gui.IgnoreGuiInset = true
	gui.ResetOnSpawn = false

	local f = Instance.new("Frame", gui)
	f.AnchorPoint = Vector2.new(0.5, 0)
	f.Position = UDim2.new(0.5, 0, 0, 240)
	f.Size = UDim2.new(0, 0, 0, 30)
	f.BackgroundColor3 = Color3.fromRGB(120, 30, 30)
	f.BackgroundTransparency = 1
	f.ClipsDescendants = true
	Instance.new("UICorner", f).CornerRadius = UDim.new(0, 4)

	local s = Instance.new("UIStroke", f)
	s.Thickness = 1.75
	s.Transparency = 1
	s.Color = Color3.fromRGB(255, 120, 120)

	local t = Instance.new("TextLabel", f)
	t.Size = UDim2.new(1, -10, 1, 0)
	t.Position = UDim2.new(0, 5, 0, 0)
	t.BackgroundTransparency = 1
	t.Font = Enum.Font.SourceSansBold
	t.TextSize = 15
	t.TextColor3 = Color3.fromRGB(255, 220, 220)
	t.TextStrokeTransparency = 0.5
	t.TextTransparency = 1
	t.Text = "Script not Available in this Experience!"

	local function show()
		local sz = TSrv:GetTextSize(t.Text, t.TextSize, t.Font, Vector2.new(1000,30))
		TS:Create(f, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Size = UDim2.new(0, sz.X + 20, 0, sz.Y + 10),
			BackgroundTransparency = 0
		}):Play()
		TS:Create(t, TweenInfo.new(0.25), {TextTransparency = 0}):Play()
		TS:Create(s, TweenInfo.new(0.25), {Transparency = 0.3}):Play()
	end

	local function hide()
		TS:Create(f, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 0, 0, f.AbsoluteSize.Y),
			BackgroundTransparency = 1
		}):Play()
		TS:Create(t, TweenInfo.new(0.25), {TextTransparency = 1}):Play()
		TS:Create(s, TweenInfo.new(0.25), {Transparency = 1}):Play()
	end

	show()
	task.delay(2.5, function()
		hide()
		task.delay(0.3, function() gui:Destroy() end)
	end)

	return
end

--// Hook ray function (for aimbot)
local filterray = filtergc("function", { Name = "castRay" })

--// Silent Aim / Aimbot Settings
local DOT_THRESHOLD = 0.15
local AIM_PART = "Head"
local RayParams = RaycastParams.new()
RayParams.FilterType = Enum.RaycastFilterType.Blacklist
local SilentAimEnabled = false -- OFF by default

--// GUI Toggles (all OFF by default)
local ESPEnabled = false
local ESPBox = false
local ESPHealth = false
local ESPNames = false
local ESPDistance = false
local ESPTracers = false
local FOVCircleEnabled = false
local FOV_RADIUS = 175
local RapidFireEnabled = false -- New Rapid Fire toggle

--========================
--// Items for Inmate ESP
--========================
local INMATE_ITEMS = {
    ["Key card"] = true,
    ["Remington 870"] = true,
    ["M9"] = true,
    ["M4A1"] = true,
    ["Hammer"] = true,
    ["Crude Knife"] = true,
}

--// Check if Inmate has any watched items
local function inmateHasItem(plr)
    if not plr or not plr.Character then return false end

    -- Check Backpack
    local backpack = plr:FindFirstChild("Backpack")
    if backpack then
        for _, tool in ipairs(backpack:GetChildren()) do
            if INMATE_ITEMS[tool.Name] then
                return true
            end
        end
    end

    -- Check Character
    local char = plr.Character
    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA("Tool") and INMATE_ITEMS[tool.Name] then
            return true
        end
    end

    return false
end

--========================
--// Notification System
--========================
local showing = false
local function rnd(n)
	n = math.min(n, 15)
	local c, t, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", {}, ''
	for v in c:gmatch"." do t[#t+1] = v end
	for i = 1, n do s ..= t[math.random(#t)] end
	return s
end

local mainGui = Instance.new("ScreenGui")
mainGui.Name = rnd(12)
mainGui.IgnoreGuiInset = true
mainGui.ResetOnSpawn = false
mainGui.Parent = Core

local notifyFrame = Instance.new("Frame")
notifyFrame.AnchorPoint = Vector2.new(0.5, 0)
notifyFrame.Position = UDim2.new(0.5, 0, 0, 240)
notifyFrame.Size = UDim2.new(0, 0, 0, 30)
notifyFrame.BackgroundColor3 = Color3.fromRGB(120, 30, 30)
notifyFrame.BackgroundTransparency = 1
notifyFrame.ClipsDescendants = true
notifyFrame.Parent = mainGui
Instance.new("UICorner", notifyFrame).CornerRadius = UDim.new(0, 4)

local notifyStroke = Instance.new("UIStroke", notifyFrame)
notifyStroke.Thickness = 1.75
notifyStroke.Transparency = 1
notifyStroke.Color = Color3.fromRGB(255, 120, 120)

local notifyLabel = Instance.new("TextLabel")
notifyLabel.Size = UDim2.new(1, -10, 1, 0)
notifyLabel.Position = UDim2.new(0, 5, 0, 0)
notifyLabel.BackgroundTransparency = 1
notifyLabel.Font = Enum.Font.SourceSansBold
notifyLabel.TextSize = 15
notifyLabel.TextColor3 = Color3.fromRGB(255, 220, 220)
notifyLabel.TextStrokeTransparency = 0.5
notifyLabel.TextTransparency = 1
notifyLabel.Text = ""
notifyLabel.Parent = notifyFrame

local function showFrame(text)
	notifyLabel.Text = text
	local sz = TSrv:GetTextSize(text, 15, notifyLabel.Font, Vector2.new(1000, 30))
	TS:Create(notifyFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, sz.X + 20, 0, sz.Y + 10),
		BackgroundTransparency = 0
	}):Play()
	TS:Create(notifyLabel, TweenInfo.new(0.25), { TextTransparency = 0 }):Play()
	TS:Create(notifyStroke, TweenInfo.new(0.25), { Transparency = 0.3 }):Play()
	showing = true
end

local function hideFrame()
	if not showing then return end
	TS:Create(notifyFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, notifyFrame.AbsoluteSize.Y),
		BackgroundTransparency = 1
	}):Play()
	TS:Create(notifyLabel, TweenInfo.new(0.25), { TextTransparency = 1 }):Play()
	TS:Create(notifyStroke, TweenInfo.new(0.25), { Transparency = 1 }):Play()
	showing = false
end

local fovCircle = Instance.new("Frame")
fovCircle.AnchorPoint = Vector2.new(0.5,0.5)
fovCircle.Position = UDim2.new(0.5,0,0.5,0)
fovCircle.Size = UDim2.new(0,FOV_RADIUS*2,0,FOV_RADIUS*2)
fovCircle.BackgroundTransparency = 1
fovCircle.Visible = FOVCircleEnabled
fovCircle.Parent = mainGui
Instance.new("UICorner", fovCircle).CornerRadius = UDim.new(1,0)

local stroke = Instance.new("UIStroke", fovCircle)
stroke.Thickness = 2
stroke.Color = Color3.fromRGB(255,255,255)
stroke.Transparency = 0

--========================
--// ESP Helpers
--========================
local ESPs = {}
local lockedTarget = nil

local function shouldShowESP(targetPlr)
	if not targetPlr or not targetPlr.Team or not player.Team then return false end
	if targetPlr == player then return false end
	if targetPlr.Team == player.Team then return false end
	return true
end

local function getTeamColor(plr)
	if not plr.Team then return Color3.fromRGB(255,255,255) end
	local teamName = plr.Team.Name
	if teamName == "Guards" then
		return Color3.fromRGB(0,170,255)
	elseif teamName == "Criminals" then
		return Color3.fromRGB(255,60,60)
	elseif teamName == "Inmates" then
		return Color3.fromRGB(255,170,0)
	else
		return Color3.fromRGB(255,255,255)
	end
end

--========================
--// ESP System
--========================
local function createESP(plr)
	if plr == player or ESPs[plr] then return end

	local box = Drawing.new("Square")
	box.Visible = false box.Thickness = 2 box.Filled = false box.Transparency = 1

	local healthBar = Drawing.new("Square")
	healthBar.Visible = false healthBar.Filled = true healthBar.Thickness = 1 healthBar.Transparency = 1

	local nameText = Drawing.new("Text")
	nameText.Center = true nameText.Outline = true nameText.Size = 18
	nameText.Color = Color3.fromRGB(255,255,255) nameText.Font = 2 nameText.Visible = false

	local distanceText = Drawing.new("Text")
	distanceText.Center = true distanceText.Outline = true distanceText.Size = 16
	distanceText.Color = Color3.fromRGB(255,255,0) distanceText.Font = 2 distanceText.Visible = false

	local tracerLine = Drawing.new("Line")
	tracerLine.Visible = false
	tracerLine.Color = Color3.fromRGB(255,255,255)
	tracerLine.Thickness = 1.5

	ESPs[plr] = {Box=box, HealthBar=healthBar, NameText=nameText, DistanceText=distanceText, Tracer=tracerLine}
end

local function removeESP(plr)
	local esp = ESPs[plr]
	if esp then
		esp.Box:Remove()
		esp.HealthBar:Remove()
		esp.NameText:Remove()
		esp.DistanceText:Remove()
		esp.Tracer:Remove()
		ESPs[plr] = nil
	end
end

local lockTracer = Drawing.new("Line")
lockTracer.Visible = false
lockTracer.Thickness = 2.8
lockTracer.Transparency = 1
lockTracer.Color = Color3.fromRGB(144, 255, 144)

RS.RenderStepped:Connect(function()
    if lockedTarget and lockedTarget.Character and lockedTarget.Character:FindFirstChild(AIM_PART) then
        local part = lockedTarget.Character[AIM_PART]
        local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)

        if onScreen then
            local fromPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
            local toPos = Vector2.new(screenPos.X, screenPos.Y)

            lockTracer.Visible = true
            lockTracer.From = fromPos
            lockTracer.To = toPos
        else
            lockTracer.Visible = false
        end
    else
        lockTracer.Visible = false
    end
end)

for _, plr in ipairs(Plr:GetPlayers()) do createESP(plr) end
Plr.PlayerAdded:Connect(createESP)
Plr.PlayerRemoving:Connect(removeESP)

--========================
--// Get Closest Target
--========================
local function getTarget()
	local bestTarget, bestDist = nil, math.huge
	local screenCenter = Camera.ViewportSize / 2

	for _, plr in ipairs(Plr:GetPlayers()) do
		if not shouldShowESP(plr) then continue end
		local char = plr.Character
		local hum = char and char:FindFirstChildOfClass("Humanoid")
		local part = char and char:FindFirstChild(AIM_PART)

		if hum and hum.Health > 0 and part then
			local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
			if not onScreen then continue end

			local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
			if dist > FOV_RADIUS then continue end

			local camDir = Camera.CFrame.LookVector
			local toTarget = (part.Position - Camera.CFrame.Position).Unit
			if camDir:Dot(toTarget) < DOT_THRESHOLD then continue end

			RayParams.FilterDescendantsInstances = { player.Character, char }
			local ray = Workspace:Raycast(Camera.CFrame.Position, part.Position - Camera.CFrame.Position, RayParams)
			if ray and not ray.Instance:IsDescendantOf(char) then continue end

			if dist < bestDist then
				bestDist = dist
				bestTarget = plr
			end
		end
	end
	return bestTarget
end

--========================
--// Render Loop (with Inmate item ESP)
--========================
RS.RenderStepped:Connect(function()
    fovCircle.Visible = FOVCircleEnabled
    fovCircle.Size = UDim2.new(0, FOV_RADIUS*2, 0, FOV_RADIUS*2)

    -- Always update target regardless of ESP
    local t = getTarget()
    if t ~= lockedTarget then
        lockedTarget = t
        if lockedTarget then
            showFrame("Target: " .. lockedTarget.Name)
        else
            hideFrame()
        end
    end

    -- If ESP is disabled, hide ESP drawings but still keep targeting
    if not ESPEnabled then
        for _, esp in pairs(ESPs) do
            esp.Box.Visible = false
            esp.NameText.Visible = false
            esp.DistanceText.Visible = false
            esp.HealthBar.Visible = false
            esp.Tracer.Visible = false
        end
        return
    end

    -- ESP drawing logic continues here...

	for plr, esp in pairs(ESPs) do
		if not shouldShowESP(plr) then
			esp.Box.Visible = false
			esp.NameText.Visible = false
			esp.DistanceText.Visible = false
			esp.HealthBar.Visible = false
			esp.Tracer.Visible = false
			continue
		end

		local char = plr.Character
		local hum = char and char:FindFirstChildOfClass("Humanoid")
		if hum and hum.Health > 0 then
			local cf, size = char:GetBoundingBox()
			local corners = {
				(cf * CFrame.new( size.X/2,  size.Y/2,  size.Z/2)).Position,
				(cf * CFrame.new(-size.X/2,  size.Y/2,  size.Z/2)).Position,
				(cf * CFrame.new( size.X/2, -size.Y/2,  size.Z/2)).Position,
				(cf * CFrame.new(-size.X/2, -size.Y/2,  size.Z/2)).Position,
				(cf * CFrame.new( size.X/2,  size.Y/2, -size.Z/2)).Position,
				(cf * CFrame.new(-size.X/2,  size.Y/2, -size.Z/2)).Position,
				(cf * CFrame.new( size.X/2, -size.Y/2, -size.Z/2)).Position,
				(cf * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2)).Position,
			}

			local minX, minY = math.huge, math.huge
			local maxX, maxY = -math.huge, -math.huge
			local onScreen = false

			for _, pos in ipairs(corners) do
				local screenPos, visible = Camera:WorldToViewportPoint(pos)
				if visible then
					onScreen = true
					minX = math.min(minX, screenPos.X)
					minY = math.min(minY, screenPos.Y)
					maxX = math.max(maxX, screenPos.X)
					maxY = math.max(maxY, screenPos.Y)
				end
			end

			if onScreen then
				-- Box
				esp.Box.Visible = ESPBox
				if ESPBox then
					esp.Box.Position = Vector2.new(minX, minY)
					esp.Box.Size = Vector2.new(maxX-minX, maxY-minY)
					esp.Box.Color = (plr == lockedTarget) and Color3.fromRGB(0,255,0) or getTeamColor(plr)
				end

				-- Name
				esp.NameText.Visible = ESPNames
				if ESPNames then
					esp.NameText.Text = plr.Name
					esp.NameText.Position = Vector2.new((minX+maxX)/2, minY-20)
					
					-- RED ESP for Inmates with items
					if plr.Team and plr.Team.Name == "Inmates" and inmateHasItem(plr) then
						esp.NameText.Color = Color3.fromRGB(255, 80, 80) -- criminal red-ish
					else
						esp.NameText.Color = getTeamColor(plr)
					end
				end

				-- Distance
				esp.DistanceText.Visible = ESPDistance
				if ESPDistance then
					local dist = (cf.Position - Camera.CFrame.Position).Magnitude
					esp.DistanceText.Text = string.format("[%.0f]", dist)
					esp.DistanceText.Position = Vector2.new((minX+maxX)/2, minY-36)
				end

				-- Health
				esp.HealthBar.Visible = ESPHealth
				if ESPHealth then
					local hpPercent = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
					esp.HealthBar.Size = Vector2.new(4, (maxY-minY)*hpPercent)
					esp.HealthBar.Position = Vector2.new(minX-6, maxY-esp.HealthBar.Size.Y)
					esp.HealthBar.Color = Color3.fromRGB(255*(1-hpPercent), 255*hpPercent, 0)
				end

				-- Tracer
				esp.Tracer.Visible = ESPTracers
				if ESPTracers then
					esp.Tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
					esp.Tracer.To = Vector2.new((minX+maxX)/2, maxY)
					esp.Tracer.Color = (plr == lockedTarget) and Color3.fromRGB(0,255,0) or getTeamColor(plr)
				end
			else
				esp.Box.Visible = false
				esp.NameText.Visible = false
				esp.DistanceText.Visible = false
				esp.HealthBar.Visible = false
				esp.Tracer.Visible = false
			end
		else
			esp.Box.Visible = false
			esp.NameText.Visible = false
			esp.DistanceText.Visible = false
			esp.HealthBar.Visible = false
			esp.Tracer.Visible = false
		end
	end
end)

--========================
--// Hook Raycast for Silent Aim
--========================
for _, v in filterray do
    local old
    old = hookfunction(v, newcclosure(function(origin, targetPos, spread)
        if SilentAimEnabled and lockedTarget and lockedTarget.Character and lockedTarget.Character:FindFirstChild("Head") then
            targetPos = lockedTarget.Character.Head.Position
        end
        return old(origin, targetPos, spread)
    end))
end

--========================
--// Loading Animation
--========================
local loading = true
task.spawn(function()
	local dots = 0
	while loading do
		dots = (dots % 3) + 1
		showFrame("Loading" .. string.rep(".", dots))
		task.wait(0.3)
	end
end)
task.delay(3, function()
	loading = false
	task.wait(0.35)
	hideFrame()
end)

--========================
--// Rayfield GUI
--========================
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
	Name = "Matrix Hub",
	LoadingTitle = "Loading Assets",
	LoadingSubtitle = "by MISHKO & tester",
	ConfigurationSaving = { Enabled = true, FolderName = "MyGameConfigs", FileName = "Config" }
})

--// Misc Tab
local MiscTab = Window:CreateTab("Misc", 4483362458)
MiscTab:CreateToggle({ Name = "Silent Aim", CurrentValue = false, Flag = "SilentAim_Toggle", Callback = function(Value)
	SilentAimEnabled = Value
	showFrame("Silent Aim " .. (Value and "Enabled" or "Disabled"))
	task.delay(1.5, hideFrame)
end})
MiscTab:CreateToggle({ Name = "FOV Circle", CurrentValue = false, Flag = "FOV_Circle_Toggle", Callback = function(Value)
	FOVCircleEnabled = Value
	showFrame("FOV Circle " .. (Value and "Enabled" or "Disabled"))
	task.delay(1.5, hideFrame)
end})
MiscTab:CreateSlider({ Name = "FOV Size", Range = {50, 500}, Increment = 5, Suffix = "px", CurrentValue = FOV_RADIUS, Flag = "FOV_Slider", Callback = function(Value)
	FOV_RADIUS = Value
	showFrame("FOV Size set to "..Value)
	task.delay(1.5, hideFrame)
end})

local Cam = workspace.CurrentCamera
MiscTab:CreateSlider({
    Name = "FOV Size",
    Range = {20,120},
    Increment = 1,
    Suffix = "°",
    CurrentValue = Cam.FieldOfView,
    Flag = "FOV_Slider",
    Callback = function(Value)
        if Cam then
            Cam.FieldOfView = Value
        end
        if showFrame and hideFrame then
            showFrame("FOV set to "..Value)
            task.delay(1.5, hideFrame)
        end
    end
})

-- Storage for removed instances
local RemovedObjects = {}
local Removed = false

-- Helper function to remove and store objects
local function removeTargets()
	if Removed then return end
	Removed = true

	-- Clear old data just in case
	RemovedObjects = {}

	-- 1) Workspace.Doors and all children
	local doorsFolder = workspace:FindFirstChild("Doors")
	if doorsFolder then
		for _, obj in ipairs(doorsFolder:GetChildren()) do
			table.insert(RemovedObjects, {
				Instance = obj,
				Parent = obj.Parent
			})
			obj.Parent = nil
		end
	end

	-- 2) Workspace.Prison_Fences.Prison_Gate
	local prisonFences = workspace:FindFirstChild("Prison_Fences")
	if prisonFences then
		local prisonGate = prisonFences:FindFirstChild("Prison_Gate")
		if prisonGate then
			table.insert(RemovedObjects, {
				Instance = prisonGate,
				Parent = prisonGate.Parent
			})
			prisonGate.Parent = nil
		end
	end
end

-- Helper function to restore objects
local function restoreTargets()
	if not Removed then return end
	Removed = false

	for _, data in ipairs(RemovedObjects) do
		if data.Instance and data.Parent then
			data.Instance.Parent = data.Parent
		end
	end

	RemovedObjects = {}
end

-- Your toggle
MiscTab:CreateToggle({
	Name = "Remove Doors & Prison Gate",
	CurrentValue = false,
	Flag = "Remove_Doors_Prison_Gate_Toggle",
	Callback = function(Value)
		if Value then
			removeTargets()
			showFrame("Removed Doors & Gate")
		else
			restoreTargets()
			showFrame("Restored Doors & Gate")
		end

		task.delay(1.5, hideFrame)
	end
})



-- NoClip
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local RANGE = 2.5
local FloatValue = -3.1
local noclipEnabled = false

local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local function createBubble()
	local b = Instance.new("Part")
	b.Name = "NoclipBubble"
	b.Shape = Enum.PartType.Ball
	b.Size = Vector3.new(RANGE*2, RANGE*2, RANGE*2)
	b.Transparency = 1
	b.Color = Color3.fromRGB(0,170,255)
	b.Material = Enum.Material.ForceField
	b.Anchored = true
	b.CanCollide = false
	b.CanQuery = false
	b.CanTouch = false
	b.Parent = workspace
	return b
end

local function createFloatPad()
	local f = Instance.new("Part")
	f.Name = "FloatPlatform"
	f.Size = Vector3.new(2,0.2,1.5)
	f.Transparency = 1
	f.Anchored = true
	f.CanCollide = true
	f.Parent = workspace
	return f
end

local bubble = createBubble()
local floatPad = createFloatPad()

local modified = {}
local overlapParams = OverlapParams.new()
overlapParams.FilterType = Enum.RaycastFilterType.Blacklist
overlapParams.FilterDescendantsInstances = { character }

local function setupCharacter(char)
	character = char
	hrp = char:WaitForChild("HumanoidRootPart")
	overlapParams.FilterDescendantsInstances = { character }
	modified = {}
	if not bubble or not bubble.Parent then bubble = createBubble() end
	if not floatPad or not floatPad.Parent then floatPad = createFloatPad() end
end

player.CharacterAdded:Connect(setupCharacter)
if player.Character then setupCharacter(player.Character) end

UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.Q then FloatValue -= 0.5
	elseif input.KeyCode == Enum.KeyCode.E then FloatValue += 0.5 end
end)

MiscTab:CreateToggle({
	Name = "Noclip",
	CurrentValue = false,
	Flag = "Noclip_Toggle",
	Callback = function(Value)
		noclipEnabled = Value
		showFrame("Noclip " .. (Value and "Enabled" or "Disabled"))
		task.delay(1.5, hideFrame)
		if not Value then
			for part, data in pairs(modified) do
				if part and part.Parent then part.CanCollide = data.original end
			end
			modified = {}
		end
	end
})

RunService.RenderStepped:Connect(function()
	if not character or not hrp or not hrp.Parent then return end
	if noclipEnabled then
		if not bubble or not bubble.Parent then bubble = createBubble() end
		if not floatPad or not floatPad.Parent then floatPad = createFloatPad() end

		local targetPosition = hrp.Position + Vector3.new(0, FloatValue, 0)
		floatPad.Position = targetPosition
		bubble.Position = hrp.Position
		bubble.Size = Vector3.new(RANGE*2, RANGE*2, RANGE*2)

		local currentParts = {}
		local partsInRange = workspace:GetPartBoundsInRadius(hrp.Position, RANGE, overlapParams)
		for _, part in ipairs(partsInRange) do
			if part:IsA("BasePart") then
				currentParts[part] = true
				if not modified[part] then modified[part] = {original = part.CanCollide} end
				part.CanCollide = false
			end
		end
		for part, data in pairs(modified) do
			if not currentParts[part] or not part.Parent then
				if part and part.Parent then part.CanCollide = data.original end
				modified[part] = nil
			end
		end
	else
		for part, data in pairs(modified) do
			if part and part.Parent then part.CanCollide = data.original end
		end
		modified = {}
	end
end)


local TweenService = game:GetService("TweenService")

local BulletTracesEnabled = false
local Debounce = {} -- Tracks parts currently being cloned

-- Safe clone function
local function cloneRayPart(rayPart)
    if not BulletTracesEnabled then return end
    if not rayPart:IsA("BasePart") then return end
    if rayPart:GetAttribute("IsBulletTrace") then return end
    if Debounce[rayPart] then return end -- already processing
    Debounce[rayPart] = true

    local clone = rayPart:Clone()
    clone.Parent = workspace
    clone.Anchored = true
    clone.CanCollide = false
    clone.CanQuery = false
    clone.CanTouch = false
    clone.Color = Color3.fromRGB(200, 128, 255)
    clone.Transparency = 0.45
    clone:SetAttribute("IsBulletTrace", true)

    local tween = TweenService:Create(clone, TweenInfo.new(0.45, Enum.EasingStyle.Linear), {Transparency = 1})
    tween:Play()
    tween.Completed:Connect(function()
        clone:Destroy()
        Debounce[rayPart] = nil -- cleanup debounce
    end)
end

-- Queue system without delay
local CloneQueue = {}
local processingQueue = false

local function processQueue()
    if processingQueue then return end
    processingQueue = true

    -- Process all queued parts instantly
    while #CloneQueue > 0 do
        local part = table.remove(CloneQueue, 1)
        cloneRayPart(part)
    end

    processingQueue = false
end

-- Monitor RayParts
local function monitorRayParts(parent)
    if not parent then return end
    parent.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("BasePart") and descendant.Name == "RayPart" and not descendant:GetAttribute("IsBulletTrace") then
            table.insert(CloneQueue, descendant)
            processQueue() -- process immediately
        end
    end)
end

monitorRayParts(workspace)
monitorRayParts(workspace.CurrentCamera)

-- GUI Toggle
MiscTab:CreateToggle({
    Name = "Bullet Traces",
    CurrentValue = false,
    Flag = "BulletTraces_Toggle",
    Callback = function(Value)
        BulletTracesEnabled = Value
        if showFrame then
            showFrame("Bullet Traces " .. (Value and "Enabled" or "Disabled"))
            task.delay(1.5, function()
                if hideFrame then hideFrame() end
            end)
        end
    end
})


--// Visuals Tab
local VisualsTab = Window:CreateTab("Visuals", 4483362458)
VisualsTab:CreateToggle({ Name = "ESP", CurrentValue = false, Flag = "ESP_Toggle", Callback = function(Value)
	ESPEnabled = Value
	showFrame("ESP "..(Value and "Enabled" or "Disabled"))
	task.delay(1.5, hideFrame)
end})
VisualsTab:CreateToggle({ Name = "ESP Box", CurrentValue = false, Flag = "ESP_Box_Toggle", Callback = function(Value)
	ESPBox = Value
	showFrame("ESP Box "..(Value and "Enabled" or "Disabled"))
	task.delay(1.5, hideFrame)
end})
VisualsTab:CreateToggle({ Name = "ESP Health", CurrentValue = false, Flag = "ESP_Health_Toggle", Callback = function(Value)
	ESPHealth = Value
	showFrame("ESP Health "..(Value and "Enabled" or "Disabled"))
	task.delay(1.5, hideFrame)
end})
VisualsTab:CreateToggle({ Name = "ESP Names", CurrentValue = false, Flag = "ESP_Names_Toggle", Callback = function(Value)
	ESPNames = Value
	showFrame("ESP Names "..(Value and "Enabled" or "Disabled"))
	task.delay(1.5, hideFrame)
end})
VisualsTab:CreateToggle({ Name = "ESP Distance", CurrentValue = false, Flag = "ESP_Distance_Toggle", Callback = function(Value)
	ESPDistance = Value
	showFrame("ESP Distance "..(Value and "Enabled" or "Disabled"))
	task.delay(1.5, hideFrame)
end})
VisualsTab:CreateToggle({ Name = "ESP Tracers", CurrentValue = false, Flag = "ESP_Tracers_Toggle", Callback = function(Value)
	ESPTracers = Value
	showFrame("ESP Tracers "..(Value and "Enabled" or "Disabled"))
	task.delay(1.5, hideFrame)
end})

local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local ESPEnabled = false

local function newLine()
    local l = Drawing.new("Line")
    l.Color = Color3.fromRGB(255,255,255)
    l.Thickness = 2
    l.Transparency = 1
    l.Visible = false
    return l
end

local function getLegs(char)
    local left = char:FindFirstChild("Left Leg") or char:FindFirstChild("LeftLowerLeg")
    local right = char:FindFirstChild("Right Leg") or char:FindFirstChild("RightLowerLeg")
    return left, right
end

local function getShoulderMotors(char)
    local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
    if not torso then return nil, nil end
    local left = torso:FindFirstChild("LeftShoulder") or torso:FindFirstChild("Left Shoulder")
    local right = torso:FindFirstChild("RightShoulder") or torso:FindFirstChild("Right Shoulder")
    return left, right
end

local function getWristMotors(char)
    local leftLowerArm = char:FindFirstChild("LeftLowerArm") or char:FindFirstChild("Left Arm")
    local rightLowerArm = char:FindFirstChild("RightLowerArm") or char:FindFirstChild("Right Arm")
    local leftWrist = leftLowerArm and (leftLowerArm:FindFirstChild("LeftWrist") or leftLowerArm:FindFirstChild("Left Wrist"))
    local rightWrist = rightLowerArm and (rightLowerArm:FindFirstChild("RightWrist") or rightLowerArm:FindFirstChild("Right Wrist"))
    return leftWrist, rightWrist, leftLowerArm, rightLowerArm
end

local function getNeckMotor(char)
    local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
    if not torso then return nil end
    return torso:FindFirstChild("Neck")
end

local function getMotorWorldPos(motor)
    if not motor or not motor.Part0 then return nil end
    return (motor.Part0.CFrame * motor.C0).Position
end

local function drawLineWorld(p1, p2, line)
    if not p1 or not p2 then
        line.Visible = false
        return
    end
    local s1, on1 = Camera:WorldToViewportPoint(p1)
    local s2, on2 = Camera:WorldToViewportPoint(p2)
    if on1 and on2 then
        line.From = Vector2.new(s1.X, s1.Y)
        line.To = Vector2.new(s2.X, s2.Y)
        line.Visible = true
    else
        line.Visible = false
    end
end

local function getTeamColor(player)
    if not player.Team then return Color3.fromRGB(255,255,255) end
    local t = player.Team.Name
    if t == "Guards" then return Color3.fromRGB(0,170,255)
    elseif t == "Criminals" then return Color3.fromRGB(255,60,60)
    elseif t == "Inmates" then return Color3.fromRGB(255,170,0)
    else return Color3.fromRGB(255,255,255) end
end

local skeletons = {}

local function createSkeletonESP(player)
    if player == LocalPlayer then return end
    if LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team then return end -- ignore same team
    local leftLegLine = newLine()
    local rightLegLine = newLine()
    local leftToRootLine = newLine()
    local rightToRootLine = newLine()
    local leftArmLine = newLine()
    local rightArmLine = newLine()
    local leftShoulderToRootLine = newLine()
    local rightShoulderToRootLine = newLine()
    local rootToNeckLine = newLine()

    skeletons[player] = {leftLegLine,rightLegLine,leftToRootLine,rightToRootLine,leftArmLine,rightArmLine,leftShoulderToRootLine,rightShoulderToRootLine,rootToNeckLine}

    RunService.RenderStepped:Connect(function()
        if not ESPEnabled then
            for _, l in pairs(skeletons[player]) do l.Visible = false end
            return
        end
        local char = player.Character
        if not char then
            for _, l in pairs(skeletons[player]) do l.Visible = false end
            return
        end
        if LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team then
            for _, l in pairs(skeletons[player]) do l.Visible = false end
            return
        end
        local color = getTeamColor(player)
        for _, l in pairs(skeletons[player]) do l.Color = color end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local leftLeg, rightLeg = getLegs(char)
        local leftShoulderMotor, rightShoulderMotor = getShoulderMotors(char)
        local leftWristMotor, rightWristMotor, leftArmPart, rightArmPart = getWristMotors(char)
        local neckMotor = getNeckMotor(char)
        if not hrp or not leftLeg or not rightLeg then return end
        local function updateLeg(leg, legLine, connectorLine)
            local cf = leg.CFrame
            local halfHeight = leg.Size.Y / 2
            local topWorld = cf.Position + cf.UpVector * halfHeight
            local bottomWorld = cf.Position - cf.UpVector * (halfHeight * 0.5)
            drawLineWorld(topWorld, bottomWorld, legLine)
            drawLineWorld(topWorld, hrp.Position, connectorLine)
        end
        updateLeg(leftLeg, leftLegLine, leftToRootLine)
        updateLeg(rightLeg, rightLegLine, rightToRootLine)
        local function updateArmLine(shoulderMotor, wristMotor, armPart, line)
            local shoulderPos = getMotorWorldPos(shoulderMotor)
            if not shoulderPos then line.Visible = false return end
            local handPos
            if wristMotor then
                handPos = getMotorWorldPos(wristMotor)
                if handPos then
                    local dir = (handPos - shoulderPos).Unit
                    local shorten = 0.25 * (handPos - shoulderPos).Magnitude
                    handPos = handPos - dir * shorten
                end
            elseif armPart then
                local armBottom = armPart.CFrame.Position - armPart.CFrame.UpVector * (armPart.Size.Y / 2)
                local dir = (armBottom - shoulderPos).Unit
                local shorten = 0.25 * (armBottom - shoulderPos).Magnitude
                handPos = armBottom - dir * shorten
            end
            drawLineWorld(shoulderPos, handPos, line)
        end
        updateArmLine(leftShoulderMotor, leftWristMotor, leftArmPart, leftArmLine)
        updateArmLine(rightShoulderMotor, rightWristMotor, rightArmPart, rightArmLine)
        drawLineWorld(hrp.Position, getMotorWorldPos(leftShoulderMotor), leftShoulderToRootLine)
        drawLineWorld(hrp.Position, getMotorWorldPos(rightShoulderMotor), rightShoulderToRootLine)
        drawLineWorld(hrp.Position, getMotorWorldPos(neckMotor), rootToNeckLine)
    end)
end

for _, plr in ipairs(Players:GetPlayers()) do createSkeletonESP(plr) end
Players.PlayerAdded:Connect(createSkeletonESP)

VisualsTab:CreateToggle({
    Name = "ESP Skeletons",
    CurrentValue = false,
    Flag = "ESP_Skeletons_Toggle",
    Callback = function(Value)
        ESPEnabled = Value
        showFrame("ESP Skeletons "..(Value and "Enabled" or "Disabled"))
        task.delay(1.5, hideFrame)
    end
})

local player = game.Players.LocalPlayer
local RapidFireEnabled = false 
local config
local mods = {
    FireRate = 0,
    SpreadRadius = 0,
    AccurateRange = 1000,
    Range = 3000
}

local function applyMods()
    local shoots = filtergc("function", {Name = "shoot"})
    for _, fn in pairs(shoots) do
        local ups = getupvalues(fn)
        while not ups[10] do task.wait(0.1); ups = getupvalues(fn) end
        config = ups[10]
        break
    end
    if config then
        for k,v in pairs(mods) do
            if config[k] ~= nil then
                config[k] = v
            end
        end
    else
    end
end

-- Apply mods when a tool is equipped
local function onToolAdded(tool)
    if tool:IsA("Tool") and RapidFireEnabled then
        task.wait(0.5)
        applyMods()
    end
end

-- Connect tool equip for current and future characters
local function connectCharacter(char)
    -- When a new tool is added
    char.ChildAdded:Connect(onToolAdded)
    -- Apply mods for existing tools
    for _, tool in pairs(char:GetChildren()) do
        onToolAdded(tool)
    end
end

local AutoShootEnabled = false

-- Rapid Fire Toggle in Misc Tab
MiscTab:CreateToggle({
    Name = "Rapid Fire",
    CurrentValue = false,
    Flag = "RapidFire_Toggle",
    Callback = function(Value)
        RapidFireEnabled = Value
        showFrame("Rapid Fire "..(Value and "Enabled" or "Disabled"))
        task.delay(1.5, hideFrame)
        if Value and player.Character then
            connectCharacter(player.Character)
        end
    end
})

-- Auto Shoot Toggle
MiscTab:CreateToggle({
    Name = "Auto Shoot",
    CurrentValue = false,
    Flag = "AutoShoot_Toggle",
    Callback = function(Value)
        AutoShootEnabled = Value
        showFrame("Auto Shoot "..(Value and "Enabled" or "Disabled"))
        task.delay(1.5, hideFrame)
    end
})

-- Connect for character respawn
player.CharacterAdded:Connect(function(char)
    task.wait(1)
    if RapidFireEnabled then
        connectCharacter(char)
    end
end)

-- Auto-clicker settings
local CPS = 50
local delayTime = 1 / CPS

-- Spam clicker loop (ONLY when locked on target AND AutoShoot is ON)
task.spawn(function()
    while true do
        task.wait()
        if RapidFireEnabled and AutoShootEnabled and lockedTarget then
            local char = player.Character or player.CharacterAdded:Wait()
            local tool = char:FindFirstChildWhichIsA("Tool")
            if tool then
                mouse1press()
                task.wait(0.001)
                mouse1release()
                task.wait(delayTime)
            else
                task.wait(0.1)
            end
        else
            task.wait(0.1)
        end
    end
end)

local ToolsTab = Window:CreateTab("Tools", 4483362458)
ToolsTab:CreateButton({Name="AK47 - detectedable!",Callback=function()
    local p=game.Players.LocalPlayer
    local h=(p.Character or p.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
    local o=h.CFrame
    h.CFrame=CFrame.new(-931.769,94.368,2039.459)
    task.spawn(function()h.CFrame=h.CFrame*CFrame.new(0,1,0) task.wait(0.05) h.CFrame=h.CFrame-Vector3.new(0,1,0) end)
    task.delay(0.25,function()if h and h.Parent then h.CFrame=o end end)
    showFrame("AK47 added to Inventory!") task.delay(1.5,hideFrame)
end})
ToolsTab:CreateButton({Name="Remington 870 - detectedable!",Callback=function()
    local p=game.Players.LocalPlayer
    local h=(p.Character or p.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
    local o=h.CFrame
    h.CFrame=CFrame.new(820.359,100.735,2229.438)
    task.spawn(function()h.CFrame=h.CFrame*CFrame.new(0,1,0) task.wait(0.05) h.CFrame=h.CFrame-Vector3.new(0,1,0) end)
    task.delay(0.25,function()if h and h.Parent then h.CFrame=o end end)
    showFrame("Remington 870 added to Inventory!") task.delay(1.5,hideFrame)
end})
ToolsTab:CreateButton({Name="MP5 - detectedable!",Callback=function()
    local p=game.Players.LocalPlayer
    local h=(p.Character or p.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
    local o=h.CFrame
    h.CFrame=CFrame.new(813.645,100.795,2229.438)
    task.spawn(function()h.CFrame=h.CFrame*CFrame.new(0,1,0) task.wait(0.05) h.CFrame=h.CFrame-Vector3.new(0,1,0) end)
    task.delay(0.25,function()if h and h.Parent then h.CFrame=o end end)
    showFrame("MP5 added to Inventory!") task.delay(1.5,hideFrame)
end})

local CreditsTab = Window:CreateTab("‎Credits", 4483362458)
CreditsTab:CreateLabel(" ")
CreditsTab:CreateLabel("Created by: MISHKO & testerdevv")
CreditsTab:CreateLabel("Discord: mishkox & testerdevv")
CreditsTab:CreateLabel("Thank you for using this script!")
CreditsTab:CreateLabel(" ")
